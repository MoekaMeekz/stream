<script src="/socket.io/socket.io.js"></script>
<script>
  const socket = io();
  let username = "";
  let canStream = false;
  const peers = {};
  let streamerId = null;

  async function login() {
    const email = document.getElementById("emailInput").value.trim();
    const password = document.getElementById("passwordInput").value;

    if (!email || !password) {
      alert("Please enter email and password.");
      return;
    }

    try {
      const res = await fetch("/api/login", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ email, password })
      });

      const data = await res.json();
      if (!res.ok) {
        alert(data.error || "Login failed");
        return;
      }

      username = data.username;
      canStream = data.canStream;

      socket.emit("login", username);

      document.getElementById("loginDiv").style.display = "none";
      document.getElementById("appDiv").style.display = "block";

      if (canStream) {
        startWebRTC();
        addChat(`Welcome, ${username}! You can stream now.`);
      } else {
        addChat(`You joined the chat as ${username}. Streaming is only allowed for VanellopeVonSchweetz.`);
        startWebRTC();
      }
    } catch (err) {
      console.error(err);
      alert("An error occurred during login.");
    }
  }

  function startWebRTC() {
    const localVideo = document.getElementById("localVideo");

    if (canStream) {
      navigator.mediaDevices.getDisplayMedia({
        video: true,
        audio: {
          echoCancellation: false,
          noiseSuppression: false,
          sampleRate: 44100
        }
      }).then(stream => {
        localVideo.srcObject = stream;
        localVideo.muted = true;

        console.log("ðŸŽ¥ Stream tracks:", stream.getTracks());

        socket.on("new-viewer", (viewerId) => {
          const peer = new RTCPeerConnection();
          stream.getTracks().forEach(track => peer.addTrack(track, stream));
          peer.onicecandidate = e => {
            if (e.candidate) {
              socket.emit("signal", {
                to: viewerId,
                from: socket.id,
                data: { candidate: e.candidate }
              });
            }
          };

          peer.createOffer().then(offer => {
            peer.setLocalDescription(offer);
            socket.emit("signal", {
              to: viewerId,
              from: socket.id,
              data: { offer }
            });
          });

          peers[viewerId] = peer;
        });
      }).catch(err => {
        console.error("ðŸš« Could not capture screen + audio:", err);
        alert("Screen/audio sharing was denied or failed.");
      });
    } else {
      const remoteStream = new MediaStream();
      localVideo.srcObject = remoteStream;
      localVideo.muted = false;

      const peer = new RTCPeerConnection();

      peer.ontrack = (e) => {
        remoteStream.addTrack(e.track);
        console.log("ðŸ”Š Received track:", e.track.kind);
      };

      peer.onicecandidate = e => {
        if (e.candidate && streamerId) {
          socket.emit("signal", {
            to: streamerId,
            from: socket.id,
            data: { candidate: e.candidate }
          });
        }
      };

      peers[socket.id] = peer;
    }

    socket.on("signal", async ({ from, data }) => {
      if (!peers[from]) {
        const peer = new RTCPeerConnection();
        peer.ontrack = (e) => {
          const remoteStream = new MediaStream([e.track]);
          document.getElementById("localVideo").srcObject = remoteStream;
          document.getElementById("localVideo").muted = false;
        };
        peer.onicecandidate = e => {
          if (e.candidate) {
            socket.emit("signal", { to: from, from: socket.id, data: { candidate: e.candidate } });
          }
        };
        peers[from] = peer;
        streamerId = from;
      }

      const peer = peers[from];

      if (data.offer) {
        await peer.setRemoteDescription(new RTCSessionDescription(data.offer));
        const answer = await peer.createAnswer();
        await peer.setLocalDescription(answer);
        socket.emit("signal", { to: from, from: socket.id, data: { answer } });
      } else if (data.answer) {
        await peer.setRemoteDescription(new RTCSessionDescription(data.answer));
      } else if (data.candidate) {
        await peer.addIceCandidate(new RTCIceCandidate(data.candidate));
      }
    });

    socket.on("viewer-disconnected", id => {
      if (peers[id]) {
        peers[id].close();
        delete peers[id];
      }
    });
  }

  function goFullscreen() {
    const video = document.getElementById("localVideo");
    if (video.requestFullscreen) {
      video.requestFullscreen();
    } else if (video.webkitRequestFullscreen) {
      video.webkitRequestFullscreen(); // Safari
    } else if (video.msRequestFullscreen) {
      video.msRequestFullscreen(); // IE11
    }
  }

  function toggleDarkMode() {
    document.body.classList.toggle("dark-mode");
  }

  function sendMsg() {
    const msgInput = document.getElementById("msgInput");
    const msg = msgInput.value;
    if (!msg.trim()) return;
    socket.emit("chat message", msg);
    addChat(`You: ${msg}`);
    msgInput.value = "";
  }

  socket.on("chat message", (msg) => {
    const chat = document.getElementById("chat");
    const div = document.createElement("div");
    div.textContent = msg;
    chat.appendChild(div);
    chat.scrollTop = chat.scrollHeight;
  });

  function addChat(message) {
    const chat = document.getElementById("chat");
    const div = document.createElement("div");
    div.textContent = message;
    chat.appendChild(div);
    chat.scrollTop = chat.scrollHeight;
  }

  window.sendMsg = sendMsg;
</script>
