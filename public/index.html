<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Streaming App</title>
<style>
  body { font-family: Arial, sans-serif; max-width: 700px; margin: 20px auto; }
  video { width: 100%; background: black; }
  #chat { height: 150px; overflow-y: auto; border: 1px solid #ccc; padding: 10px; margin: 10px 0; }
</style>
</head>
<body>

<h2>Streaming App</h2>

<div id="loginDiv">
  <input id="emailInput" type="email" placeholder="Email" />
  <input id="passwordInput" type="password" placeholder="Password" />
  <button onclick="login()">Login</button>
</div>

<div id="appDiv" style="display:none;">
  <video id="video" autoplay playsinline></video>
  <button id="startStreamBtn" style="display:none;">Start Streaming</button>

  <div id="chat"></div>
  <input id="msgInput" placeholder="Type message..." />
  <button onclick="sendMessage()">Send</button>
</div>

<script src="/socket.io/socket.io.js"></script>
<script>
  const socket = io();

  let username = null;
  let canStream = false;
  let localStream = null;
  let peers = {}; // For streamer: key = viewer socketId, value = RTCPeerConnection
  let viewerPeer = null; // For viewer: single peer connection to streamer
  let currentStreamerId = null;

  const loginDiv = document.getElementById('loginDiv');
  const appDiv = document.getElementById('appDiv');
  const videoEl = document.getElementById('video');
  const chatDiv = document.getElementById('chat');
  const startStreamBtn = document.getElementById('startStreamBtn');

  // ===== LOGIN =====
  async function login() {
    const email = document.getElementById('emailInput').value.trim();
    const password = document.getElementById('passwordInput').value;

    if (!email || !password) {
      alert("Please fill in email and password");
      return;
    }

    try {
      const res = await fetch('/api/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password }),
      });
      const data = await res.json();

      if (!res.ok) {
        alert(data.error || "Login failed");
        return;
      }

      username = data.username;
      canStream = data.canStream;

      socket.emit('login', username);

      loginDiv.style.display = 'none';
      appDiv.style.display = 'block';

      addChat(`Welcome ${username}!`);

      if (canStream) {
        startStreamBtn.style.display = 'inline-block';
      }
    } catch (err) {
      console.error(err);
      alert("Error during login");
    }
  }

  // ===== CHAT =====
  socket.on('chat message', msg => {
    addChat(msg);
  });

  function sendMessage() {
    const input = document.getElementById('msgInput');
    const msg = input.value.trim();
    if (!msg) return;
    socket.emit('chat message', msg);
    input.value = '';
  }

  function addChat(msg) {
    const p = document.createElement('p');
    p.textContent = msg;
    chatDiv.appendChild(p);
    chatDiv.scrollTop = chatDiv.scrollHeight;
  }

  // ===== STREAMER =====
  startStreamBtn.onclick = async () => {
    try {
      localStream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: false });
      videoEl.srcObject = localStream;
      videoEl.muted = true; // Mute self to avoid feedback
      await videoEl.play();
      addChat('Started streaming. Waiting for viewers...');

      socket.on('new-viewer', handleNewViewer);
    } catch (err) {
      console.error('Failed to start stream:', err);
      alert('Could not start streaming: ' + err.message);
    }
  };

  async function handleNewViewer(viewerId) {
    console.log('New viewer:', viewerId);
    const peer = new RTCPeerConnection({
      iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
    });

    // Add all tracks from the stream to the peer connection
    localStream.getTracks().forEach(track => peer.addTrack(track, localStream));

    peer.onicecandidate = e => {
      if (e.candidate) {
        socket.emit('signal', { to: viewerId, from: socket.id, data: { candidate: e.candidate } });
      }
    };

    // Create offer and send to viewer
    try {
      const offer = await peer.createOffer();
      await peer.setLocalDescription(offer);
      socket.emit('signal', { to: viewerId, from: socket.id, data: { offer: peer.localDescription } });
    } catch (err) {
      console.error('Error creating offer:', err);
    }

    peers[viewerId] = peer;
  }

  // ===== VIEWER =====
  socket.on('streamer-available', async (streamerSocketId) => {
    currentStreamerId = streamerSocketId;
    if (!canStream && streamerSocketId) {
      addChat('Streamer is available, connecting...');
      await connectToStreamer(streamerSocketId);
    } else if (!streamerSocketId) {
      addChat('Streamer disconnected.');
      if (videoEl.srcObject) {
        videoEl.srcObject.getTracks().forEach(track => track.stop());
        videoEl.srcObject = null;
      }
    }
  });

  async function connectToStreamer(streamerId) {
    if (viewerPeer) {
      viewerPeer.close();
      viewerPeer = null;
    }

    viewerPeer = new RTCPeerConnection({
      iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
    });

    viewerPeer.ontrack = (event) => {
      console.log('Received remote track');
      if (videoEl.srcObject !== event.streams[0]) {
        videoEl.srcObject = event.streams[0];
        videoEl.muted = false;
        videoEl.play();
        addChat('Streaming started');
      }
    };

    viewerPeer.onicecandidate = (e) => {
      if (e.candidate) {
        socket.emit('signal', { to: streamerId, from: socket.id, data: { candidate: e.candidate } });
      }
    };

    // Listen for signaling messages from streamer
    socket.off('signal'); // Remove old handlers to prevent duplicates
    socket.on('signal', async ({ from, data }) => {
      if (from !== streamerId) return; // Only accept signals from current streamer

      if (data.offer) {
        // Usually viewer does not receive offer, streamer sends offer
        console.warn("Unexpected offer at viewer");
      } else if (data.answer) {
        await viewerPeer.setRemoteDescription(new RTCSessionDescription(data.answer));
      } else if (data.candidate) {
        try {
          await viewerPeer.addIceCandidate(new RTCIceCandidate(data.candidate));
        } catch (e) {
          console.error('Error adding ICE candidate', e);
        }
      }
    });
  }

  // ===== SIGNAL HANDLING FOR STREAMER =====
  socket.on('signal', async ({ from, data }) => {
    // Streamer receives answer and ICE candidates from viewers
    if (!canStream) return; // viewer does not handle here

    const peer = peers[from];
    if (!peer) {
      console.warn("No peer connection for viewer", from);
      return;
    }

    if (data.answer) {
      await peer.setRemoteDescription(new RTCSessionDescription(data.answer));
    } else if (data.candidate) {
      try {
        await peer.addIceCandidate(new RTCIceCandidate(data.candidate));
      } catch (e) {
        console.error('Error adding ICE candidate to streamer peer', e);
      }
    }
  });
</script>

</body>
</html>
